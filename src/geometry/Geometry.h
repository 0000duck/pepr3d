#pragma once

// #include <CGAL/IO/Color.h>
#include <CGAL/AABB_traits.h>
#include <CGAL/AABB_tree.h>
#include <CGAL/Polyhedron_3.h>
#include <CGAL/Polyhedron_incremental_builder_3.h>
#include <CGAL/Polyhedron_items_with_id_3.h>
#include <cassert>
#include <optional>
#include <vector>

#include "cinder/Ray.h"
#include "geometry/ColorManager.h"
#include "geometry/ModelImporter.h"
#include "geometry/Triangle.h"

namespace pepr3d {

using Direction = K::Direction_3;
using Ft = K::FT;
using Ray = K::Ray_3;
using My_AABB_traits = CGAL::AABB_traits<K, DataTriangleAABBPrimitive>;
using Tree = CGAL::AABB_tree<My_AABB_traits>;
using Ray_intersection = boost::optional<Tree::Intersection_and_primitive_id<Ray>::Type>;
typedef CGAL::Polyhedron_3<K, CGAL::Polyhedron_items_with_id_3> Polyhedron;
typedef Polyhedron::HalfedgeDS HalfedgeDS;

template <class HDS>
class Build_triangle : public CGAL::Modifier_base<HDS> {
   private:
    const std::vector<std::array<size_t, 3>>& mTriangles;
    const std::vector<glm::vec3>& mVertices;

    std::vector<typename CGAL::Polyhedron_incremental_builder_3<HDS>::Face_handle> mFacetsCreated;

   public:
    Build_triangle(const std::vector<std::array<size_t, 3>>& tris, const std::vector<glm::vec3>& verts)
        : mTriangles(tris), mVertices(verts) {}

    std::vector<typename CGAL::Polyhedron_incremental_builder_3<HDS>::Face_handle> getFacetArray() {
        assert(mFacetsCreated.size() > 0 && mFacetsCreated.size() == mTriangles.size());
        return mFacetsCreated;
    }

    void operator()(HDS& hds) {
        // Postcondition: hds is a valid polyhedral surface.
        CGAL::Polyhedron_incremental_builder_3<HDS> B(hds, true);

        mFacetsCreated.clear();
        mFacetsCreated.reserve(mTriangles.size());

        // We will create a surface with <triangle-size> faces and <vertex-size> vertices
        B.begin_surface(mVertices.size(), mTriangles.size());

        typedef typename HDS::Vertex Vertex;
        typedef typename Vertex::Point Point;

        // Add all vertices
        for(const auto& vertex : mVertices) {
            B.add_vertex(Point(vertex.x, vertex.y, vertex.z));
        }

        for(const auto& tri : mTriangles) {
            auto facetBeingAdded = B.begin_facet();
            mFacetsCreated.push_back(facetBeingAdded);
            B.add_vertex_to_facet(tri[0]);
            B.add_vertex_to_facet(tri[1]);
            B.add_vertex_to_facet(tri[2]);
            B.end_facet();
        }

        B.end_surface();

        assert(mFacetsCreated.size() == mTriangles.size());
    }
};

class Geometry {
    /// Triangle soup of the model mesh, containing CGAL::Triangle_3 data for AABB tree.
    std::vector<DataTriangle> mTriangles;

    /// Vertex buffer with the same data as mTriangles for OpenGL to render the mesh.
    /// Contains position and color data for each vertex.
    std::vector<glm::vec3> mVertexBuffer;

    /// Color buffer, keeping the invariant that every triangle has only one color - all three vertices have to have the
    /// same color. It is aligned with the vertex buffer and its size should be always equal to the vertex buffer.
    std::vector<cinder::ColorA> mColorBuffer;

    /// Normal buffer, the triangle has same normal for its every vertex.
    /// It is aligned with the vertex buffer and its size should be always equal to the vertex buffer.
    std::vector<glm::vec3> mNormalBuffer;

    /// Index buffer for OpenGL frontend., specifying the same triangles as in mTriangles.
    std::vector<uint32_t> mIndexBuffer;

    /// AABB tree from the CGAL library, to find intersections with rays generated by user mouse clicks and the mesh.
    std::unique_ptr<Tree> mTree;

    /// A vector based map mapping size_t into ci::ColorA
    ColorManager mColorManager;

    struct PolyhedronData {
        std::vector<glm::vec3> vertices;

        std::vector<std::array<size_t, 3>> indices;

        Polyhedron P;

        std::vector<CGAL::Polyhedron_incremental_builder_3<HalfedgeDS>::Face_handle> faceHandles;

        bool closeCheck = false;
    } mPolyhedronData;

   public:
    /// Empty constructor rendering a triangle to debug
    Geometry() {
        mTriangles.emplace_back(glm::vec3(-1, 0, -1), glm::vec3(-1, 0, 1), glm::vec3(1, 0, -1), glm::vec3(0, 1, 0), 0);
        mTriangles.emplace_back(glm::vec3(1, 0, -1), glm::vec3(1, 0, 1), glm::vec3(-1, 0, 1), glm::vec3(0, 1, 0), 0);

        generateVertexBuffer();
        generateColorBuffer();
        generateNormalBuffer();
        generateIndexBuffer();

        assert(mIndexBuffer.size() == mVertexBuffer.size());

        mTree = std::make_unique<Tree>(mTriangles.begin(), mTriangles.end());
        assert(mTree->size() == mTriangles.size());
    }

    /// Returns a constant iterator to the vertex buffer
    std::vector<glm::vec3>& getVertexBuffer() {
        return mVertexBuffer;
    }

    bool polyClosedCheck() const {
        return mPolyhedronData.closeCheck;
    }

    size_t polyVertCount() const {
        return mPolyhedronData.vertices.size();
    }

    /// Returns a constant iterator to the index buffer
    std::vector<uint32_t>& getIndexBuffer() {
        return mIndexBuffer;
    }

    std::vector<cinder::ColorA>& getColorBuffer() {
        return mColorBuffer;
    }

    std::vector<glm::vec3>& getNormalBuffer() {
        return mNormalBuffer;
    }

    /// Loads new geometry into the private data, rebuilds the vertex and index buffers
    /// automatically.
    void loadNewGeometry(const std::string& fileName) {
        /// Load into mTriangles
        ModelImporter modelImporter(fileName);  // only first mesh [0]
        mTriangles = modelImporter.getTriangles();

        mPolyhedronData.vertices.clear();
        mPolyhedronData.indices.clear();
        mPolyhedronData.vertices = modelImporter.getVertexBuffer();
        mPolyhedronData.indices = modelImporter.getIndexBuffer();

        /// Generate new vertex buffer
        generateVertexBuffer();

        /// Generate new index buffer
        generateIndexBuffer();

        /// Generate new color buffer from triangle color data
        generateColorBuffer();

        /// Generate new normal buffer, copying the triangle normal to each vertex
        generateNormalBuffer();

        /// Rebuild the AABB tree
        mTree->rebuild(mTriangles.begin(), mTriangles.end());  // \todo Uncomment this when CGAL is in.
        assert(mTree->size() == mTriangles.size());

        /// Get the generated color palette of the model, replace the current one
        auto palette = modelImporter.getColorPalette();
        assert(!palette.empty());
        replaceColors(palette.begin(), palette.end());

        /// Build the polyhedron data structure
        buildPolyhedron();
    }

    /// Set new triangle color
    void setTriangleColor(const size_t triangleIndex, const size_t newColor) {
        /// Change it in the buffer
        // Color buffer has 1 ColorA for each vertex, each triangle has 3 vertices
        const size_t vertexPosition = triangleIndex * 3;

        // Change all vertices of the triangle to the same new color
        assert(vertexPosition + 2 < mColorBuffer.size());
        const ci::ColorA cinderColor = mColorManager.getColor(newColor);

        mColorBuffer[vertexPosition] = cinderColor;
        mColorBuffer[vertexPosition + 1] = cinderColor;
        mColorBuffer[vertexPosition + 2] = cinderColor;

        /// Change it in the triangle soup
        assert(triangleIndex < mTriangles.size());
        mTriangles[triangleIndex].setColor(newColor);
    }

    /// Get the color of the indexed triangle
    size_t getTriangleColor(const size_t triangleIndex) {
        assert(triangleIndex < mTriangles.size());
        return mTriangles[triangleIndex].getColor();
    }

    /// Intersects the mesh with the given ray and returns the index of the triangle intersected, if it exists.
    /// Example use: generate ray based on a mouse click, call this method, then call setTriangleColor.
    std::optional<size_t> intersectMesh(const ci::Ray& ray) const {
        assert(!mTree->empty());
        const glm::vec3 source = ray.getOrigin();
        const glm::vec3 direction = ray.getDirection();

        const Ray rayQuery(Point(source.x, source.y, source.z), Direction(direction.x, direction.y, direction.z));

        // Find the two intersection parameters - place and triangle
        Ray_intersection intersection = mTree->first_intersection(rayQuery);
        if(intersection) {
            // The intersected triangle
            if(boost::get<DataTriangleAABBPrimitive::Id>(intersection->second) != mTriangles.end()) {
                const DataTriangleAABBPrimitive::Id intersectedTriIter =
                    boost::get<DataTriangleAABBPrimitive::Id>(intersection->second);
                assert(intersectedTriIter != mTriangles.end());
                const size_t retValue = intersectedTriIter - mTriangles.begin();
                assert(retValue < mTriangles.size());
                return retValue;  // convert the iterator into an index
            }
        }

        /// No intersection detected.
        return {};
    }

    /// Return the number of triangles in the model
    size_t getTriangleCount() const {
        return mTriangles.size();
    }

    /// Replace the color table with a new color table
    void replaceColors(const std::vector<ci::ColorA>::const_iterator start,
                       const std::vector<ci::ColorA>::const_iterator end) {
        mColorManager.replaceColors(start, end);
        generateColorBuffer();
    }

    /// Replace the color table with a new color table
    void replaceColors(std::vector<ci::ColorA>&& newColors) {
        mColorManager.replaceColors(std::move(newColors));
        generateColorBuffer();
    }

    size_t getColorSize() const {
        return mColorManager.size();
    }

    void bucket(const std::size_t startTriangle) {
        if(mPolyhedronData.P.is_empty()) {
            return;
        }

        std::deque<size_t> toVisit;
        const size_t startingFace = startTriangle;
        toVisit.push_back(startingFace);

        std::unordered_set<size_t> alreadyVisited;

        while(!toVisit.empty()) {
            // Remove yourself from queue and mark visited
            size_t currentVertex = toVisit.front();
            toVisit.pop_front();
            alreadyVisited.insert(currentVertex);

            // Manage neighbours and grow the queue
            addNeighboursToQueue(currentVertex, mPolyhedronData.faceHandles, alreadyVisited, toVisit);

            // Do the operation
            setTriangleColor(currentVertex, mColorManager.size() - 2);
        }
    }

   private:
    /// Generates the vertex buffer linearly - adding each vertex of each triangle as a new one.
    /// We need to do this because each triangle has to be able to be colored differently, therefore no vertex sharing
    /// is possible.
    void generateVertexBuffer() {
        mVertexBuffer.clear();
        mVertexBuffer.reserve(3 * mTriangles.size());

        for(const auto& mTriangle : mTriangles) {
            mVertexBuffer.push_back(mTriangle.getVertex(0));
            mVertexBuffer.push_back(mTriangle.getVertex(1));
            mVertexBuffer.push_back(mTriangle.getVertex(2));
        }
    }

    /// Generating a linear index buffer, since we do not reuse any vertices.
    void generateIndexBuffer() {
        mIndexBuffer.clear();
        mIndexBuffer.reserve(mVertexBuffer.size());

        for(uint32_t i = 0; i < mVertexBuffer.size(); ++i) {
            mIndexBuffer.push_back(i);
        }
    }

    /// Generating triplets of colors, since we only allow a single-colored triangle.
    void generateColorBuffer() {
        mColorBuffer.clear();
        mColorBuffer.reserve(mVertexBuffer.size());

        for(const auto& mTriangle : mTriangles) {
            const size_t triColorIndex = mTriangle.getColor();
            const ci::ColorA cinderColor = mColorManager.getColor(triColorIndex);
            mColorBuffer.push_back(cinderColor);
            mColorBuffer.push_back(cinderColor);
            mColorBuffer.push_back(cinderColor);
        }
        assert(mColorBuffer.size() == mVertexBuffer.size());
    }

    /// Generate a buffer of normals. Generates only "triangle normals" - all three vertices have the same normal.
    void generateNormalBuffer() {
        mNormalBuffer.clear();
        mNormalBuffer.reserve(mVertexBuffer.size());
        for(const auto& mTriangle : mTriangles) {
            mNormalBuffer.push_back(mTriangle.getNormal());
            mNormalBuffer.push_back(mTriangle.getNormal());
            mNormalBuffer.push_back(mTriangle.getNormal());
        }
        assert(mColorBuffer.size() == mVertexBuffer.size());
    }

    void buildPolyhedron() {
        Build_triangle<HalfedgeDS> triangle(mPolyhedronData.indices, mPolyhedronData.vertices);
        mPolyhedronData.P.clear();
        mPolyhedronData.P.delegate(triangle);
        mPolyhedronData.faceHandles = triangle.getFacetArray();

        assert(!mPolyhedronData.P.is_empty());
        assert(mPolyhedronData.P.size_of_facets() == mPolyhedronData.indices.size());
        assert(mPolyhedronData.P.size_of_vertices() == mPolyhedronData.vertices.size());

        // Use the facetsCreated from the incremental builder, set the ids linearly
        for(int facetId = 0; facetId < mPolyhedronData.faceHandles.size(); ++facetId) {
            mPolyhedronData.faceHandles[facetId]->id() = facetId;
        }

        mPolyhedronData.closeCheck = mPolyhedronData.P.is_closed();
    }

    static std::array<int, 3> gatherNeighbours(
        const size_t triIndex,
        const std::vector<CGAL::Polyhedron_incremental_builder_3<HalfedgeDS>::Face_handle>& faceHandles) {
        const Polyhedron::Facet_iterator& facet = faceHandles[triIndex];
        std::array<int, 3> returnValue = {-1, -1, -1};
        assert(facet->is_triangle());

        const auto edgeIteratorStart = facet->facet_begin();
        auto edgeIter = edgeIteratorStart;

        for(int i = 0; i < 3; ++i) {
            const auto eFace = edgeIter->facet();
            if(edgeIter->opposite()->facet() != nullptr) {
                const size_t idd = edgeIter->opposite()->facet()->id();
                returnValue[i] = static_cast<int>(idd);
            }
            ++edgeIter;
        }
        assert(edgeIter == edgeIteratorStart);

        return returnValue;
    }

    static void addNeighboursToQueue(
        const size_t currentVertex,
        const std::vector<CGAL::Polyhedron_incremental_builder_3<HalfedgeDS>::Face_handle>& faceHandles,
        std::unordered_set<size_t>& alreadyVisited, std::deque<size_t>& toVisit) {
        const std::array<int, 3> neighbours = gatherNeighbours(currentVertex, faceHandles);
        for(int i = 0; i < 3; ++i) {
            if(neighbours[i] == -1) {
                continue;
            } else {
                if(alreadyVisited.find(neighbours[i]) == alreadyVisited.end()) {
                    // New vertex -> visit it.
                    toVisit.push_back(neighbours[i]);
                    std::cout << "At triangle " << currentVertex << " queued up triangle " << neighbours[i] << "\n";
                }
            }
        }
    }
};

}  // namespace pepr3d